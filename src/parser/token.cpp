#include "token.hpp"

#include <cassert>

namespace perun {
namespace parser {

// this should be synchronized with Token::Kind
const char* getTokenName(Token::Kind kind) {
    // generated by macros in vim
    // TODO: should this be processed using the pre-processor?
    switch (kind) {
    case Token::Kind::Invalid:
        return "Invalid";
    case Token::Kind::EndOfFile:
        return "EndOfFile";
    case Token::Kind::LParen:
        return "LParen";
    case Token::Kind::RParen:
        return "RParen";
    case Token::Kind::LBrace:
        return "LBrace";
    case Token::Kind::RBrace:
        return "RBrace";
    case Token::Kind::LBracket:
        return "LBracket";
    case Token::Kind::RBracket:
        return "RBracket";
    case Token::Kind::Ampersand:
        return "Ampersand";
    case Token::Kind::AmpersandEq:
        return "AmpersandEq";
    case Token::Kind::At:
        return "At";
    case Token::Kind::Backslash:
        return "Backslash";
    case Token::Kind::Bang:
        return "Bang";
    case Token::Kind::BangEq:
        return "BangEq";
    case Token::Kind::Caret:
        return "Caret";
    case Token::Kind::Colon:
        return "Colon";
    case Token::Kind::Comma:
        return "Comma";
    case Token::Kind::Dot:
        return "Dot";
    case Token::Kind::DotDot:
        return "DotDot";
    case Token::Kind::DotDotDot:
        return "DotDotDot";
    case Token::Kind::Eq:
        return "Eq";
    case Token::Kind::EqEq:
        return "EqEq";
    case Token::Kind::EqGreater:
        return "EqGreater";
    case Token::Kind::Greater:
        return "Greater";
    case Token::Kind::GreaterEq:
        return "GreaterEq";
    case Token::Kind::GreaterGreater:
        return "GreaterGreater";
    case Token::Kind::GreaterGreaterEq:
        return "GreaterGreaterEq";
    case Token::Kind::Hash:
        return "Hash";
    case Token::Kind::Less:
        return "Less";
    case Token::Kind::LessEq:
        return "LessEq";
    case Token::Kind::LessLess:
        return "LessLess";
    case Token::Kind::LessLessEq:
        return "LessLessEq";
    case Token::Kind::Minus:
        return "Minus";
    case Token::Kind::MinusEq:
        return "MinusEq";
    case Token::Kind::MinusGreater:
        return "MinusGreater";
    case Token::Kind::Percent:
        return "Percent";
    case Token::Kind::PercentEq:
        return "PercentEq";
    case Token::Kind::PercentPercent:
        return "PercentPercent";
    case Token::Kind::PercentPercentEq:
        return "PercentPercentEq";
    case Token::Kind::Pipe:
        return "Pipe";
    case Token::Kind::PipeEq:
        return "PipeEq";
    case Token::Kind::Plus:
        return "Plus";
    case Token::Kind::PlusEq:
        return "PlusEq";
    case Token::Kind::PlusPlus:
        return "PlusPlus";
    case Token::Kind::Question:
        return "Question";
    case Token::Kind::QuestionEq:
        return "QuestionEq";
    case Token::Kind::Semicolon:
        return "Semicolon";
    case Token::Kind::Slash:
        return "Slash";
    case Token::Kind::SlashEq:
        return "SlashEq";
    case Token::Kind::Star:
        return "Star";
    case Token::Kind::StarEq:
        return "StarEq";
    case Token::Kind::StarStar:
        return "StarStar";
    case Token::Kind::Tilde:
        return "Tilde";
    case Token::Kind::TildeEq:
        return "TildeEq";
    case Token::Kind::KeywordAlign:
        return "KeywordAlign";
    case Token::Kind::KeywordAnd:
        return "KeywordAnd";
    case Token::Kind::KeywordAsm:
        return "KeywordAsm";
    case Token::Kind::KeywordBreak:
        return "KeywordBreak";
    case Token::Kind::KeywordCatch:
        return "KeywordCatch";
    case Token::Kind::KeywordConst:
        return "KeywordConst";
    case Token::Kind::KeywordContinue:
        return "KeywordContinue";
    case Token::Kind::KeywordDefer:
        return "KeywordDefer";
    case Token::Kind::KeywordElse:
        return "KeywordElse";
    case Token::Kind::KeywordEnum:
        return "KeywordEnum";
    case Token::Kind::KeywordError:
        return "KeywordError";
    case Token::Kind::KeywordExport:
        return "KeywordExport";
    case Token::Kind::KeywordExtern:
        return "KeywordExtern";
    case Token::Kind::KeywordFalse:
        return "KeywordFalse";
    case Token::Kind::KeywordFn:
        return "KeywordFn";
    case Token::Kind::KeywordFor:
        return "KeywordFor";
    case Token::Kind::KeywordIf:
        return "KeywordIf";
    case Token::Kind::KeywordIn:
        return "KeywordIn";
    case Token::Kind::KeywordMatch:
        return "KeywordMatch";
    case Token::Kind::KeywordNil:
        return "KeywordNil";
    case Token::Kind::KeywordNot:
        return "KeywordNot";
    case Token::Kind::KeywordOr:
        return "KeywordOr";
    case Token::Kind::KeywordPriv:
        return "KeywordPriv";
    case Token::Kind::KeywordPub:
        return "KeywordPub";
    case Token::Kind::KeywordPure:
        return "KeywordPure";
    case Token::Kind::KeywordReturn:
        return "KeywordReturn";
    case Token::Kind::KeywordStruct:
        return "KeywordStruct";
    case Token::Kind::KeywordThis:
        return "KeywordThis";
    case Token::Kind::KeywordTrue:
        return "KeywordTrue";
    case Token::Kind::KeywordTry:
        return "KeywordTry";
    case Token::Kind::KeywordUndefined:
        return "KeywordUndefined";
    case Token::Kind::KeywordUnion:
        return "KeywordUnion";
    case Token::Kind::KeywordUse:
        return "KeywordUse";
    case Token::Kind::KeywordVar:
        return "KeywordVar";
    case Token::Kind::KeywordVolatile:
        return "KeywordVolatile";
    case Token::Kind::KeywordWhile:
        return "KeywordWhile";
    case Token::Kind::LiteralChar:
        return "LiteralChar";
    case Token::Kind::LiteralFloat:
        return "LiteralFloat";
    case Token::Kind::LiteralInteger:
        return "LiteralInteger";
    case Token::Kind::LiteralCRawString:
        return "LiteralCRawString";
    case Token::Kind::LiteralCString:
        return "LiteralCString";
    case Token::Kind::LiteralRawString:
        return "LiteralRawString";
    case Token::Kind::LiteralString:
        return "LiteralString";
    case Token::Kind::Identifier:
        return "Identifier";
    case Token::Kind::LineComment:
        return "LineComment";
    case Token::Kind::DocComment:
        return "DocComment";
    default:
        assert(false);
    }
}

bool isKeyword(const std::string& str) {
    for (const Keyword& kw : keywords) {
        if (kw.str == str) {
            return true;
        }
    }
    return false;
}

Token::Kind getKeyword(const std::string& str) {
    for (const Keyword& kw : keywords) {
        if (kw.str == str) {
            return kw.kind;
        }
    }

    return Token::Kind::Invalid;
}

} // namespace parser
} // namespace perun
